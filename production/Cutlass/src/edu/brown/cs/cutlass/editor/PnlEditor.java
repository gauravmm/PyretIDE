/*
 * Cutlass - Pyret IDE
 * For CSCI 0320 Spring 2014, Term Project
 */
package edu.brown.cs.cutlass.editor;

import edu.brown.cs.cutlass.editor.callgraph.CallGraphEntry;
import edu.brown.cs.cutlass.parser.PyretFeatureExtractor;
import edu.brown.cs.cutlass.parser.PyretMetadata;
import edu.brown.cs.cutlass.parser.tokenizer.Token;
import edu.brown.cs.cutlass.parser.tokenizer.TokenParserOutput;
import edu.brown.cs.cutlass.sys.io.AbstractIOException;
import edu.brown.cs.cutlass.sys.io.AbstractIdentifier;
import edu.brown.cs.cutlass.ui.FrmFinder;
import edu.brown.cs.cutlass.sys.pyret.AbstractPyretAccess;
import edu.brown.cs.cutlass.sys.pyret.PyretAccessListener;
import edu.brown.cs.cutlass.sys.pyret.PyretOutputValue;
import edu.brown.cs.cutlass.sys.pyret.PyretTerminationValue;
import edu.brown.cs.cutlass.util.Lumberjack;
import edu.brown.cs.cutlass.util.Option;
import java.awt.Color;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;
import javax.swing.text.StyledEditorKit;

/**
 *'2
 * @author Gaurav Manek
 * @param <T>
 */
public class PnlEditor<T extends AbstractIdentifier> extends Editor<T> {

    private final EditorClient editorClient;
    private final StyledUndoPane editorPane;
    private final PnlLineNumbers pnlLineNumber;
    private AbstractPyretAccess<T> pyret_instance;

    /**
     * Creates new form EditorPanel
     *
     * @param client
     * @param initialContents The initial contents of the editor panel
     */
    public PnlEditor(EditorClient client, String initialContents) {
        super(true);
        initComponents();

        this.editorClient = client;
        
        // Prepare and add editor pane
        this.editorPane = new StyledUndoPane(initialContents, new PyretHighlightedListener() {
            @Override
            public void highlighted(TokenParserOutput output, Option<Token> currentToken, EditorJumpToClient client) {
                if (pnlLineNumber != null) {
                    pnlLineNumber.stateChanged(null);
                }
                PyretMetadata extract = PyretFeatureExtractor.extract(output);
                TreeSet<CallGraphEntry> callGraphEntries = new TreeSet<>(PyretFeatureExtractor.getCallGraphEntries(extract, currentToken, client));
                editorClient.handleQuickNavigationChange(callGraphEntries);
            }
        });
        final PnlEditor<T> editor = this;
        editorPane.getDocument().addDocumentListener(new DocumentListener(){
            @Override
            public void insertUpdate(DocumentEvent e) {
                changedUpdate(e);
            }
            @Override
            public void removeUpdate(DocumentEvent e) {
                changedUpdate(e);
            }
            @Override
            public void changedUpdate(DocumentEvent e) {
                editor.setChangedSinceLastSave(true);
            } 
        });
        
        pnlLineNumber = new PnlLineNumbers(editorPane);
        pnlLineNumberContainer.add(pnlLineNumber);
        scrlEditor.getViewport().removeAll();
        scrlEditor.getViewport().add(editorPane);
        scrlEditor.getViewport().addChangeListener(pnlLineNumber);

        // The output pane is outputPane
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        pnlEditArea = new javax.swing.JPanel();
        scrlEditor = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        pnlLineNumberContainer = new javax.swing.JPanel();
        pnlOut = new javax.swing.JPanel();
        scrlCMD = new javax.swing.JScrollPane();
        outputPane = new javax.swing.JEditorPane();

        setLayout(new java.awt.CardLayout());

        jSplitPane1.setDividerLocation(400);
        jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
        jSplitPane1.setResizeWeight(1.0);

        pnlEditArea.setLayout(new java.awt.BorderLayout());

        scrlEditor.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scrlEditor.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jTextArea1.setText("\ndata BinaryTree:\n  | mt\n  | node(value :: Number, left :: BinaryTree, right :: BinaryTree)\nend\n\nfun tree-to-list(tree :: BinaryTree) -> List:\n  doc: \"tree-to-list converts a binary tree into a list, preserving the order of the stored values.\"\n  cases(BinaryTree) tree:\n    | mt => []\n    | node(v, l, r) => tree-to-list(l) + [v] + tree-to-list(r)\n  end\nwhere:\n  tree-to-list(mt) is []\n  tree-to-list(node(4, node(2, mt, mt), node(6, mt, mt))) is [2, 4, 6]\nend\n\nfun is-sorted(lst :: List) -> Bool:\n  doc: \"is-sorted returns true if the list is sorted in ascending order.\"\n   cases(List) lst:\n    | empty => true\n    | link(f, r) => \n      min-rest = for fold(min from f+1, elt from r):\n          if (elt < min):\n            elt\n          else:\n            min\n          end\n      end\n      ((f < min-rest) and is-sorted(r))\n  end\nwhere:\n  is-sorted([]) is true\n  is-sorted([1]) is true\n  is-sorted([1, 2, 3]) is true\n  is-sorted([1, 3, 2]) is false\nend\nfun is-bst(tree :: BinaryTree) -> Bool:\n  doc: \"is-bst returns true if tree is a Binary Search Tree and false otherwise.\"\n  is-sorted(tree-to-list(tree))\nwhere:\n  is-bst(mt) is true\n  is-bst(node(4, node(2, mt, mt), node(6, mt, mt))) is true\n  is-bst(node(1, node(2, mt, mt), node(6, mt, mt))) is false\n  is-bst(node(4, node(5, mt, mt), node(6, mt, mt))) is false\nend\n\n");
        scrlEditor.setViewportView(jTextArea1);

        pnlEditArea.add(scrlEditor, java.awt.BorderLayout.CENTER);

        pnlLineNumberContainer.setMaximumSize(new java.awt.Dimension(80, 32767));
        pnlLineNumberContainer.setMinimumSize(new java.awt.Dimension(60, 100));
        pnlLineNumberContainer.setPreferredSize(new java.awt.Dimension(40, 399));
        pnlLineNumberContainer.setLayout(new java.awt.CardLayout());
        pnlEditArea.add(pnlLineNumberContainer, java.awt.BorderLayout.LINE_START);

        jSplitPane1.setLeftComponent(pnlEditArea);

        pnlOut.setPreferredSize(new java.awt.Dimension(108, 200));
        pnlOut.setLayout(new java.awt.CardLayout());

        scrlCMD.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scrlCMD.setViewportView(outputPane);

        pnlOut.add(scrlCMD, "card2");

        jSplitPane1.setRightComponent(pnlOut);

        add(jSplitPane1, "card2");
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JEditorPane outputPane;
    private javax.swing.JPanel pnlEditArea;
    private javax.swing.JPanel pnlLineNumberContainer;
    private javax.swing.JPanel pnlOut;
    private javax.swing.JScrollPane scrlCMD;
    private javax.swing.JScrollPane scrlEditor;
    // End of variables declaration//GEN-END:variables

    @Override
    public void run() {
        try {
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
            pyret_instance = editorClient.getPyretAccess(this);
            outputPane.setEditorKit(new StyledEditorKit());
            final StyledDocument sdoc = (StyledDocument) outputPane.getDocument();
            
            final Style output_style = sdoc.addStyle("OUTPUT STYLE", null);
            StyleConstants.setForeground(output_style, Color.green);
            
            final Style error_style = sdoc.addStyle("ERROR STYLE", null);
            StyleConstants.setForeground(error_style, Color.red);
            
            pyret_instance.addPyretAccessListener(new PyretAccessListener() {
                
                @Override
                public void handlePyretAccessOutput(final PyretOutputValue output) {
                    javax.swing.SwingUtilities.invokeLater(new Runnable() {
                        
                        @Override
                        public void run() {
                            try {
                                if (output.getStream().equals(AbstractPyretAccess.Stream.STDOUT)) {
                                    sdoc.insertString(sdoc.getLength(), output.getData() + "\n", output_style);
                                }
                                if (output.getStream().equals(AbstractPyretAccess.Stream.STDERR)) {
                                    sdoc.insertString(sdoc.getLength(), output.getData() + "\n", error_style);
                                }
                            } catch (BadLocationException e) {
                                Lumberjack.log(Lumberjack.Level.ERROR, e);
                            }
                        }
                    });
                }

                @Override
                public void handlePyretAccessEnds(PyretTerminationValue output) {
                }
            });
            pyret_instance.execute();
        } catch (AbstractIOException ex) {
            Lumberjack.log(Lumberjack.Level.ERROR, ex);
        }
    }

    @Override
    public void halt() throws IllegalStateException {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void paste(String paste) {
        int dot = editorPane.getCaret().getDot();
        String current = editorPane.getText();
        editorPane.setText(current.substring(0, dot) + paste + current.substring(editorPane.getCaret().getMark()));
        editorPane.setCaretPosition(dot + paste.length());
    }

    @Override
    public String getBuffer() {
        return editorPane.getText();
    }

    @Override
    public boolean hasSelection() {
        return editorPane.getSelectionStart() != editorPane.getSelectionEnd();
    }

    @Override
    public String getSelection() {
        return editorPane.getSelectedText();
    }

    @Override
    public void selectAll() {
        editorPane.setSelectionStart(0);
        editorPane.setSelectionEnd(editorPane.getText().length());
    }

    @Override
    public void deleteSelection() {
        int dot = editorPane.getCaret().getDot();
        String current = editorPane.getText();
        editorPane.setText(current.substring(0, dot) + current.substring(editorPane.getCaret().getMark()));
        editorPane.setCaretPosition(dot);
    }

    @Override
    public void redo() {
        editorPane.redo();
    }

    @Override
    public void undo() {
        editorPane.undo();
    }

    @Override
    public void reindent() {
        editorPane.reindent();
    }

    @Override
    public void toggleComment() {
        editorPane.toggleComment();
    }

    @Override
    public boolean findNext(FrmFinder.FindType type, boolean matchCase, boolean forwards, boolean wholeWords, String find) {
        return editorPane.findNext(type, matchCase, forwards, wholeWords, find);
    }

    @Override
    public boolean replaceNext(FrmFinder.FindType type, boolean matchCase, boolean forwards, boolean wholeWords, String find, String replace) {
        return editorPane.replaceNext(type, matchCase, forwards, wholeWords, find, replace);
    }

    @Override
    public boolean replaceAll(FrmFinder.FindType type, boolean matchCase, boolean forwards, boolean wholeWords, String find, String replace) {
        return editorPane.replaceAll(type, matchCase, forwards, wholeWords, find, replace);
    }

    @Override
    public void showCallGraph() {
        editorPane.showCallGraph();
    }

    @Override
    public void close() throws RuntimeException {
        this.removeAll();
    }

    @Override
    public void pyretClose() {
        try {
            outputPane.setEditorKit(new StyledEditorKit());
            final StyledDocument sdoc = (StyledDocument) outputPane.getDocument();

            final Style stop_style = sdoc.addStyle("STOP STYLE", null);
            StyleConstants.setForeground(stop_style, Color.red);

            this.pyret_instance.close();

            sdoc.insertString(sdoc.getLength(), "User halted program execution...", stop_style);
        } catch (BadLocationException ex) {
            Lumberjack.log(Lumberjack.Level.ERROR, ex);
        }
    }
}
