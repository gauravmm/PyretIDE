<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Mirrored from www.pyret.org/docs/s_forms.html by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 24 Apr 2014 07:13:04 GMT -->
<head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><title>3&nbsp;Language Constructs</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default" /><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="http://www.pyret.org/docs/index.html" class="tocviewlink" data-pltdoc="x">Pyret Language Reference</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="s_installing.html" class="tocviewlink" data-pltdoc="x">Installing Pyret</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="s_running.html" class="tocviewlink" data-pltdoc="x">Editing and Running Pyret</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#" class="tocviewselflink" data-pltdoc="x">Language Constructs</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="s_testing.html" class="tocviewlink" data-pltdoc="x">Testing</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="s_lists.html" class="tocviewlink" data-pltdoc="x">Lists</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="s_arrays.html" class="tocviewlink" data-pltdoc="x">Arrays</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="s_timing.html" class="tocviewlink" data-pltdoc="x">Timing Pyret Programs</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="s_cmdline.html" class="tocviewlink" data-pltdoc="x">Handling Command-<wbr></wbr>line Arguments</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="s_option.html" class="tocviewlink" data-pltdoc="x">Option</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="s_set.html" class="tocviewlink" data-pltdoc="x">Sets</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="s_numbers.html" class="tocviewlink" data-pltdoc="x">Numbers</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="s_strings.html" class="tocviewlink" data-pltdoc="x">Strings</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="s_misc.html" class="tocviewlink" data-pltdoc="x">Miscellaneous Functions</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="s_mutables.html" class="tocviewlink" data-pltdoc="x">Mutables</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="s_placeholders.html" class="tocviewlink" data-pltdoc="x">Placeholders</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="s_ast.html" class="tocviewlink" data-pltdoc="x">AST</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>3&nbsp;</td><td><a href="#" class="tocviewselflink" data-pltdoc="x">Language Constructs</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="#%28part._s~3aprogram%29" class="tocviewlink" data-pltdoc="x">Programs</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="#%28part._.Import_.Statements%29" class="tocviewlink" data-pltdoc="x">Import Statements</a></td></tr><tr><td align="right">3.3&nbsp;</td><td><a href="#%28part._.Provide_.Statements%29" class="tocviewlink" data-pltdoc="x">Provide Statements</a></td></tr><tr><td align="right">3.4&nbsp;</td><td><a href="#%28part._.Blocks%29" class="tocviewlink" data-pltdoc="x">Blocks</a></td></tr><tr><td align="right">3.5&nbsp;</td><td><a href="#%28part._.Statements%29" class="tocviewlink" data-pltdoc="x">Statements</a></td></tr><tr><td align="right">3.6&nbsp;</td><td><a href="#%28part._.Expressions%29" class="tocviewlink" data-pltdoc="x">Expressions</a></td></tr><tr><td align="right">3.7&nbsp;</td><td><a href="#%28part._s~3aannotations%29" class="tocviewlink" data-pltdoc="x">Annotations</a></td></tr><tr><td align="right">3.8&nbsp;</td><td><a href="#%28part._.Complete_.Grammar%29" class="tocviewlink" data-pltdoc="x">Complete Grammar</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#(part._s~3aprogram)" class="tocsubseclink" data-pltdoc="x">Programs</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#(part._.Import_.Statements)" class="tocsubseclink" data-pltdoc="x">Import Statements</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#(part._.Provide_.Statements)" class="tocsubseclink" data-pltdoc="x">Provide Statements</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="#(part._.Blocks)" class="tocsubseclink" data-pltdoc="x">Blocks</a></td></tr><tr><td><span class="tocsublinknumber">3.5<tt>&nbsp;</tt></span><a href="#(part._.Statements)" class="tocsubseclink" data-pltdoc="x">Statements</a></td></tr><tr><td><span class="tocsublinknumber">3.5.1<tt>&nbsp;</tt></span><a href="#(part._s~3alet-expr)" class="tocsubseclink" data-pltdoc="x">Let Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.5.2<tt>&nbsp;</tt></span><a href="#(part._s~3agraph-expr)" class="tocsubseclink" data-pltdoc="x">Graph Declarations</a></td></tr><tr><td><span class="tocsublinknumber">3.5.3<tt>&nbsp;</tt></span><a href="#(part._s~3afun-expr)" class="tocsubseclink" data-pltdoc="x">Function Declaration Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.5.4<tt>&nbsp;</tt></span><a href="#(part._s~3adata-expr)" class="tocsubseclink" data-pltdoc="x">Data Declarations</a></td></tr><tr><td><a href="#(part._s~3amutable-data)" class="tocsubnonseclink" data-pltdoc="x"><span style="font-style: italic">Mutable and Cyclic Fields</span></a></td></tr><tr><td><span class="tocsublinknumber">3.5.5<tt>&nbsp;</tt></span><a href="#(part._s~3avar-expr)" class="tocsubseclink" data-pltdoc="x">Variable Declarations</a></td></tr><tr><td><span class="tocsublinknumber">3.5.6<tt>&nbsp;</tt></span><a href="#(part._s~3aassign-expr)" class="tocsubseclink" data-pltdoc="x">Assignment Statements</a></td></tr><tr><td><span class="tocsublinknumber">3.6<tt>&nbsp;</tt></span><a href="#(part._.Expressions)" class="tocsubseclink" data-pltdoc="x">Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.1<tt>&nbsp;</tt></span><a href="#(part._s~3aget-bang-expr)" class="tocsubseclink" data-pltdoc="x">Mutable Lookup Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.2<tt>&nbsp;</tt></span><a href="#(part._s~3aupdate-expr)" class="tocsubseclink" data-pltdoc="x">Update Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.3<tt>&nbsp;</tt></span><a href="#(part._s~3alam-expr)" class="tocsubseclink" data-pltdoc="x">Lambda Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.4<tt>&nbsp;</tt></span><a href="#(part._s~3aapp-expr)" class="tocsubseclink" data-pltdoc="x">Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.5<tt>&nbsp;</tt></span><a href="#(part._s~3aleft-apply-expr)" class="tocsubseclink" data-pltdoc="x">Caret Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.6<tt>&nbsp;</tt></span><a href="#(part._s~3acurried-apply-expr)" class="tocsubseclink" data-pltdoc="x">Curried Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.7<tt>&nbsp;</tt></span><a href="#(part._s~3abinop-expr)" class="tocsubseclink" data-pltdoc="x">Binary Operators</a></td></tr><tr><td><span class="tocsublinknumber">3.6.8<tt>&nbsp;</tt></span><a href="#(part._s~3aobj-expr)" class="tocsubseclink" data-pltdoc="x">Object Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.9<tt>&nbsp;</tt></span><a href="#(part._s~3alist-expr)" class="tocsubseclink" data-pltdoc="x">List Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.10<tt>&nbsp;</tt></span><a href="#(part._s~3adot-expr)" class="tocsubseclink" data-pltdoc="x">Dot Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.11<tt>&nbsp;</tt></span><a href="#(part._s~3acolon-expr)" class="tocsubseclink" data-pltdoc="x">Colon Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.12<tt>&nbsp;</tt></span><a href="#(part._s~3aextend-expr)" class="tocsubseclink" data-pltdoc="x">Extend Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.13<tt>&nbsp;</tt></span><a href="#(part._s~3aif-expr)" class="tocsubseclink" data-pltdoc="x">If Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.14<tt>&nbsp;</tt></span><a href="#(part._s~3acases-expr)" class="tocsubseclink" data-pltdoc="x">Cases Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.15<tt>&nbsp;</tt></span><a href="#(part._s~3afor-expr)" class="tocsubseclink" data-pltdoc="x">For Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.6.16<tt>&nbsp;</tt></span><a href="#(part._s~3atry-expr)" class="tocsubseclink" data-pltdoc="x">Try Expressions</a></td></tr><tr><td><span class="tocsublinknumber">3.7<tt>&nbsp;</tt></span><a href="#(part._s~3aannotations)" class="tocsubseclink" data-pltdoc="x">Annotations</a></td></tr><tr><td><span class="tocsublinknumber">3.7.1<tt>&nbsp;</tt></span><a href="#(part._s~3aname-ann)" class="tocsubseclink" data-pltdoc="x">Name Annotations</a></td></tr><tr><td><span class="tocsublinknumber">3.7.2<tt>&nbsp;</tt></span><a href="#(part._s~3aarrow-ann)" class="tocsubseclink" data-pltdoc="x">Arrow Annotations</a></td></tr><tr><td><span class="tocsublinknumber">3.8<tt>&nbsp;</tt></span><a href="#(part._.Complete_.Grammar)" class="tocsubseclink" data-pltdoc="x">Complete Grammar</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">5.3.6</span></div><div class="navsettop"><span class="navleft">&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="s_running.html" title="backward to &quot;2 Editing and Running Pyret&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="http://www.pyret.org/docs/index.html" title="up to &quot;Pyret Language Reference&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_testing.html" title="forward to &quot;4 Testing&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>3<tt>&nbsp;</tt><a name="(part._s~3aforms)"></a>Language Constructs</h3><h4>3.1<tt>&nbsp;</tt><a name="(part._s~3aprogram)"></a>Programs</h4><p>Programs consist of a sequence of import or provide statements, followed by a
block:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">program: prelude block</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">prelude: (import-stmt|provide-stmt)*</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">block: stmt*</span></span></p></td></tr></table></blockquote><h4>3.2<tt>&nbsp;</tt><a name="(part._.Import_.Statements)"></a>Import Statements</h4><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Import and provide statements aren&rsquo;t available in Captain Teach;
the page is responsible for providing all the needed libraries.</p></blockquote></blockquote></blockquote><p>Import statements come in two forms:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">import-stmt: "import" (import-name | import-string) "as" NAME</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">import-name: NAME</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">import-string: STRING</span></span></p></td></tr></table></blockquote><p>Both forms bind the value provided by the target (either <span class="stt">import-name</span> or
<span class="stt">import-string</span>) to the <span class="stt">NAME</span> after <span class="stt">as</span>.</p><p>The form with <span class="stt">STRING</span> as a target transforms the import into a Racket require
statement, using the string as the module path.  For example, given this
<span class="stt">"m.arr"</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">provide m end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">m = 22</span></span></p></td></tr></table></blockquote><p>Another file in the same directory could use it:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">import "m.arr" as m</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">print(m) # prints 22</span></span></p></td></tr></table></blockquote><p>It is an error if the file does not exist, or does not have a provide
statement.</p><p>The form that uses a <span class="stt">NAME</span> production looks for a file with that name in the
built-in libraries of Pyret.  These are currently found in the <span class="stt">lang/racket-ffi/</span>
directory of Pyret, and are maintained by the Pyret authors.</p><p>Example:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">import io as IO</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">IO.read-line()</span></span></p></td></tr></table></blockquote><p>It is an error if there is no such named file in <span class="stt">lang/racket-ffi/</span>, or if the
file does not provide an identifier named <span class="stt">%PYRET-PROVIDE</span>.</p><h4>3.3<tt>&nbsp;</tt><a name="(part._.Provide_.Statements)"></a>Provide Statements</h4><p>A provide statement comes in one of two forms:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">provide-stmt: "provide" stmt "end" | "provide" "*"</span></span></p></td></tr></table></blockquote><p>Both forms have no effect when the program is run as the top-level program
(e.g. in a Captain Teach editor, DrRacket buffer, or as the target of <span class="stt">raco
pyret</span>).</p><p>When the program is in a file that is evaluated via <span class="stt">import</span>, the program is
run, and then the <span class="stt">provide</span> statement is run in top-level scope to determine
the value bound to the identifier in the import statement.</p><p>In the first form, the <span class="stt">stmt</span> internal to the provide is evaluated, and the
resulting value is provided.</p><p>The second form is syntactic sugar for:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">provide {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">id: id,</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">} end</span></span></p></td></tr></table></blockquote><h4>3.4<tt>&nbsp;</tt><a name="(part._.Blocks)"></a>Blocks</h4><p>A block&rsquo;s syntax is a list of statements:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">block: stmt*</span></span></p></td></tr></table></blockquote><p>Blocks serve two roles in Pyret:</p><ul><li><p>Sequencing of operations</p></li><li><p>Units of lexical scope</p></li></ul><p>The <span class="stt">let-expr</span>, <span class="stt">fun-expr</span>, <span class="stt">data-expr</span>, and <span class="stt">var-expr</span> forms are
handled specially and non-locally within blocks.  They all define names that
are in scope for all expressions in the block.</p><p>Example:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">fun f(): x end # x is defined when f evaluates</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">x = 12</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">f() # evaluates to 12</span></span></p></td></tr></table></blockquote><p>Example:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">data Node:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| node(in :: Edge, out :: Edge) # Edge is visible</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">data Edge:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| edge(weight :: Number)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><p>There is one gotcha, which is that if identifiers are evaluated before they are
defined, as opposed to just being closed over, Pyret throws an exception:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">x = y</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">y = 9</span></span></p></td></tr></table></blockquote><p>(Note: Right now this program runs but it shouldn&rsquo;t.  The value of <span class="stt">x</span> is
<span class="stt">#&lt;undefined&gt;</span>, which is an issue with a designed but un-implemented fix.)</p><p>The sections on the individual statements describe which names they introduce
into the scope.</p><p>Blocks evaluate each of their statements in order, and evaluate to the value of
the final statement in the block.</p><h4>3.5<tt>&nbsp;</tt><a name="(part._.Statements)"></a>Statements</h4><p>There are a number of forms that can only appear as statements in <span class="stt">block</span>s
and <span class="stt">provide</span> expressions:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">stmt: let-expr | fun-expr | data-expr | when-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| var-expr | assign-expr | binop-expr</span></span></p></td></tr></table></blockquote><h5>3.5.1<tt>&nbsp;</tt><a name="(part._s~3alet-expr)"></a>Let Expressions</h5><p>Let expressions are written with an equals sign:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">let-expr: binding "=" binop-expr</span></span></p></td></tr></table></blockquote><p>A let statement causes the name in the <span class="stt">binding</span> to be put in scope in the
current block, and upon evaluation sets the value to be the result of
evaluating the <span class="stt">binop-expr</span>.  The resulting binding cannot be changed via an
<span class="stt">assign-expr</span>, and cannot be shadowed by other bindings within the same or
nested scopes:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">x = 5</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">x := 10</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># Error: x is not assignable</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr></table></blockquote><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">x = 5</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">x = 10</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># Error: x defined twice</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr></table></blockquote><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">x = 5</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">fun f():</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x = 10</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># Error: can't use the name x in two nested scopes</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr></table></blockquote><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">fun f():</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x = 10</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">fun g():</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x = 22</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># Not an error: x is used in two scopes that are not nested</span></span></p></td></tr></table></blockquote><h5>3.5.2<tt>&nbsp;</tt><a name="(part._s~3agraph-expr)"></a>Graph Declarations</h5><p>Graph declarations look like a series of let statements:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">graph-expr: "graph:" let-expr* "end"</span></span></p></td></tr></table></blockquote><p>They behave like let statements, binding variables in the block in which they
appear.  However, they allow for the creation of mutual references between
data.  For example:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">check:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">graph:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">BOS = [PVD, WOR]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">WOR = [BOS]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">PVD = [BOS]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">BOS.first is PVD</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">BOS.rest.first is WOR</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">WOR.first is BOS</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">PVD.first is BOS</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><p>If we wrote this with a let expression, we would run in the gotcha about using
an identifier before we defined it.  But <span class="stt">graph:</span> keeps track of these
mutual references and causes the right relationships to hold at the end of the
<span class="stt">graph:</span> block.  Fields that use a graph identifier need to be declared as
<span class="stt">cyclic</span> in their data declaration, otherwise an error results.</p><h5>3.5.3<tt>&nbsp;</tt><a name="(part._s~3afun-expr)"></a>Function Declaration Expressions</h5><p>Function declarations have a number of pieces:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">fun-expr: "fun" fun-header ":" doc-string block where-clause "end"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">fun-header: ty-params NAME args return-ann</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">ty-params:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">["&lt;" list-ty-param* NAME "&gt;"]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-ty-param: NAME ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">args: (PARENSPACE|PARENNOSPACE) [list-arg-elt* binding] ")"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-arg-elt: binding ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">return-ann: ["-&gt;" ann]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">doc-string: ["doc:" STRING]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">where-clause: ["where:" block]</span></span></p></td></tr></table></blockquote><p>A function expression is syntactic sugar for a let and an anonymous function
expression.  The statement:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">"fun" ty-params NAME args return-ann ":"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc-string</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where-clause</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">"end"</span></span></p></td></tr></table></blockquote><p>Is equivalent to</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">NAME "=" "fun" ty-params args return-ann ":"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc-string</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">"end"</span></span></p></td></tr></table></blockquote><p>With the <span class="stt">where-clause</span> registered in <a href="s_testing.html#%28part._s~3acheck%2Fwhere%29" data-pltdoc="x">check
mode</a>.  Concretely:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">fun f(x, y):</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x + y</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><p>is equivalent to</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">f = fun(x, y):</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x + y</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><p>See the documentation for <span class="stt">lambda-exprs</span> for an explanation of arguments&rsquo;
and annotations&rsquo; behavior, as well as <span class="stt">doc-strings</span>.</p><h5>3.5.4<tt>&nbsp;</tt><a name="(part._s~3adata-expr)"></a>Data Declarations</h5><p>Data declarations define a number of related functions for creating and
manipulating a data type.  Their grammar is:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">data-expr: "data" NAME ty-params data-mixins ":"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">data-variant*</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">data-sharing</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where-clause</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"end"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">data-mixins: ["deriving" mixins]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">data-variant: "|" NAME variant-members data-with | "|" NAME data-with</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">variant-members: (PARENSPACE|PARENNOSPACE) [list-variant-member* variant-member] ")"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-variant-member: variant-member ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">variant-member: ["mutable"|"cyclic"] binding</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">data-with: ["with:" fields]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">data-sharing: ["sharing:" fields]</span></span></p></td></tr></table></blockquote><p>A <span class="stt">data-expr</span> causes a number of new names to be bound in the scope of the
block it is defined in:</p><ul><li><p>The <span class="stt">NAME</span> of the data definition</p></li><li><p><span class="stt">NAME</span>, for each variant of the data definition</p></li><li><p><span class="stt">is-NAME</span>, for each variant of the data definition</p></li></ul><p>For example, in this data definition:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">data BTree:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| node(value :: Number, left :: BTree, right :: BTree)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| leaf(value :: Number)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><p>These names are defined, with the given types:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">BTree :: (Any -&gt; Bool)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">node :: (Number, BTree, BTree -&gt; BTree)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">is-node :: (Any -&gt; Bool)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">leaf :: (Number -&gt; BTree)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">is-leaf :: (Any -&gt; Bool)</span></span></p></td></tr></table></blockquote><p>We call <span class="stt">node</span> and <span class="stt">leaf</span> the <span style="font-style: italic">constructors</span> of <span class="stt">BTree</span>, and they
construct values with the named fields.  They will refuse to create the value
if fields that don&rsquo;t match the annotations are given.  As with all annotations,
they are optional.  The constructed values can have their fields accessed with
<a href="#%28part._s~3adot-expr%29" data-pltdoc="x">dot expressions</a> and <a href="#%28part._s~3acolon-expr%29" data-pltdoc="x">colon
expressions</a>.</p><p>The function <span class="stt">BTree</span> is a <span style="font-style: italic">detector</span> for values created from this data
definition, and can be used as an annotation to check for values created by the
constructors of <span class="stt">BTree</span>.  <span class="stt">BTree</span> returns true when provided values
created by <span class="stt">node</span> or <span class="stt">leaf</span>, but no others.</p><p>The functions <span class="stt">is-node</span> and <span class="stt">is-leaf</span> are detectors for the values
created by the individual constructors: <span class="stt">is-node</span> will only return <span class="stt">true</span>
for values created by calling <span class="stt">node</span>, and correspondingly for <span class="stt">leaf</span>.</p><p>Here is a longer example of the behavior of detectors, field access, and
constructors:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">data BTree:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| node(value :: Number, left :: BTree, right :: BTree)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| leaf(value :: Number)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">where:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree = node(1, leaf(2), node(3, leaf(4), leaf(5)))</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">BTree(a-btree) is true</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">BTree("not-a-tree") is false</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">BTree(leaf(5)) is false</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-leaf(leaf(5)) is true</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-leaf(a-btree) is false</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-leaf("not-a-tree") is false</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-node(leaf(5)) is false</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-node(a-btree) is true</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-node("not-a-tree") is false</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.value is 1</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.left.value is 2</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.right.value is 3</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.right.left.value is 4</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.right.right.value is 4</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><p>A data definition can also define, for each instance as well as for the data
definition as a whole, a set of methods.  This is done with the keywords
<span class="stt">with:</span> and <span class="stt">sharing:</span>.  Methods defined on a variant via <span class="stt">with:</span> will
only be defined for instances of that variant, while methods defined on the
union of all the variants with <span class="stt">sharing:</span> are defined on all instances.  For
example:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">data BTree:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| node(value :: Number, left :: BTree, right :: BTree) with:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">size(self): 1 + self.left.size() + self.right.size() end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| leaf(value :: Number) with:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">size(self): 1 end,</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">increment(self): leaf(self.value + 1) end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">sharing:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">values-equal(self, other):</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">self.value == other.value</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">where:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree = node(1, leaf(2), node(3, leaf(4)))</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.values-equal(leaf(1)) is true</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">leaf(1).values-equal(a-btree) is true</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.size() is 3</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">leaf(0).size() is 1</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">leaf(1).increment() is leaf(2)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.increment() # raises error: field increment not found.</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><p>A data definition also sets up some special methods that are used by other
constructs in the language.  Most of the time, you shouldn&rsquo;t need to call these
directly, but they are present on each instance:</p><ul><li><p><span class="stt">tostring</span> is a method that produces a string
representation of the value</p></li><li><p><span class="stt">_torepr</span> is a method that produces a string that represents the
value in &ldquo;constructor form&rdquo;.  This is distinct from <span class="stt">tostring</span> in that,
for example, the <span class="stt">tostring</span> of <span class="stt">"a-str"</span> is the string value
<span class="stt">"a-str"</span>, but the <span class="stt">_torepr</span> is <span class="stt">"\"a-str\""</span>.  This produces more
meaningful REPL output, among other things.</p></li><li><p><span class="stt">_equals</span> is a method used to check equality with other values.  It
is called implicitly by the <span class="stt">==</span> operator.</p></li><li><p><span class="stt">_match</span> is a method that is used by <a href="#%28part._s~3acases-expr%29" data-pltdoc="x">cases
  expressions</a>.</p></li></ul><p><a name="(part._s~3amutable-data)"></a><span style="font-style: italic">Mutable and Cyclic Fields</span></p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>In the future, we plan to support both <span class="stt">cyclic</span> and
<span class="stt">mutable</span> on the same field.  For now, only one is allowed.</p></blockquote></blockquote></blockquote><p>Fields of variants can be optionally be defined with one of the special
modifiers <span class="stt">cyclic</span> or <span class="stt">mutable</span>.  These allow for different kinds of
stateful update of those fields.</p><p>In the variant constructor, a field marked <span class="stt">mutable</span> is wrapped in a
<a href="s_mutables.html" data-pltdoc="x"><span class="stt">Mutable</span></a> container.  The <span class="stt">Mutable</span> container is
initialized with both read and write guards for the annotation on the variant
member, if one is present.  That field can be subsequently updated with
<a href="#%28part._s~3aupdate-expr%29" data-pltdoc="x">update expressions</a> and accessed with
<a href="#%28part._s~3aget-bang-expr%29" data-pltdoc="x">mutable lookup</a>.</p><p>Example:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">data Node:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| node(mutable in :: List&lt;Node&gt;)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">where:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">n1 = node([])</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">n2 = node([n1])</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">n1!{in : [n2]}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">n1!in.first is n2</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">n2!in.first is n1</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><p>Accessing a <span class="stt">mutable</span> field with a <a href="#%28part._s~3adot-expr%29" data-pltdoc="x">dot expression</a>
will result in an error.</p><p>Cyclic fields allow for mutually-referential data to be created without
allowing it to be mutable for its entire lifetime.  Variant constructors with
<span class="stt">cyclic</span> fields do no extra work when handed most values.  However, if a
<a href="s_placeholders.html" data-pltdoc="x"><span class="stt">Placeholder</span></a> value is passed for a <span class="stt">cyclic</span>
field, it is <span style="font-style: italic">guarded</span> with the annotation on the field (if any).  Most
Pyret programs should not construct <span class="stt">Placeholders</span> directly, but should
instead use the <a href="#%28part._s~3agraph-expr%29" data-pltdoc="x"><span class="stt">graph</span></a> form, which creates
<span class="stt">Placeholders</span> and sets up mutual references between <span class="stt">cyclic</span> fields.</p><p>Example:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">data Node:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| node(cyclic in :: Node)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">where:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">graph:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">n1 = node(n2)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">n2 = node(n1)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">n1.in is n2</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">n2.in is n1</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Pedantically, <span class="stt">cyclic</span> and <span class="stt">mutable</span> fields in Pyret only
have <span style="font-style: italic">intensional</span> equality, while objects with no mutable fields enjoy
<span style="font-style: italic">extensional</span> equality.  With more sophisticated equality algorithms, it
is meaningful to provide extensional equality for <span class="stt">cyclic</span> fields.  It is
unclear if extensional equality is meaningful for <span class="stt">mutable</span> fields, because
of temporal concerns.</p></blockquote></blockquote></blockquote><p><span style="font-weight: bold">A note on equality.</span>  Both <span class="stt">cyclic</span> and <span class="stt">mutable</span> allow the
creation of objects that create cyclic data structures.  This is problematic
from the point of view of equality for two reasons:</p><ul><li><p>If a na&#239;ve structural equality algorithm compared two such objects, it
might not terminate.  A more sophisticated graph-isomorphism algorithm quickly
becomes computationally complex.</p></li><li><p>For <span class="stt">mutable</span> data, an equality algorithm that compares the contents
of two <span class="stt">Mutable</span> containers could return <span class="stt">true</span> at one point in time and
<span class="stt">false</span> at another.</p></li></ul><p>For these reasons, equality on <span class="stt">mutable</span> and <span class="stt">cyclic</span> fields only
succeeds if the <span class="stt">Mutable</span> or <span class="stt">Placeholder</span> values are <span style="font-style: italic">the same
value</span>, rather than checking the equality of their contents.  This has the
benefit of being efficient, and supporting object-identity style equality in
one case where it is often relevant: graph algorithms.</p><h5>3.5.5<tt>&nbsp;</tt><a name="(part._s~3avar-expr)"></a>Variable Declarations</h5><p>Variable declarations look like <a href="#%28part._s~3alet-expr%29" data-pltdoc="x">let bindings</a>, but
with an extra <span class="stt">var</span> keyword in the beginning:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">var-expr: "var" binding "=" expr</span></span></p></td></tr></table></blockquote><p>A <span class="stt">var</span> expression creates a new <span style="font-style: italic">assignable variable</span> in the current
scope, initialized to the value of the expression on the right of the <span class="stt">=</span>.
It can be accessed simply by using the variable name, which will always
evaluate to the last-assigned value of the variable.  <a href="#%28part._s~3aassign-expr%29" data-pltdoc="x">Assignment statements</a> can be used to update the value stored in an
assignable variable.</p><p>If the <span class="stt">binding</span> contains an annotation, the initial value is checked
against the annotation, and all <a href="#%28part._s~3aassign-expr%29" data-pltdoc="x">assignment
statements</a> to the variable check the annotation on the new value before
updating.</p><h5>3.5.6<tt>&nbsp;</tt><a name="(part._s~3aassign-expr)"></a>Assignment Statements</h5><p>Assignment statements have a name on the left, and an expression on the right
of <span class="stt">:=</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">assign-expr: NAME ":=" binop-expr</span></span></p></td></tr></table></blockquote><p>If <span class="stt">NAME</span> is not declared in the same or an outer scope of the assignment
expression with a <span class="stt">var</span> declaration, the program fails with a static error.</p><p>At runtime, an assignment expression changes the value of the assignable
variable <span class="stt">NAME</span> to the result of the right-hand side expression.</p><h4>3.6<tt>&nbsp;</tt><a name="(part._.Expressions)"></a>Expressions</h4><h5>3.6.1<tt>&nbsp;</tt><a name="(part._s~3aget-bang-expr)"></a>Mutable Lookup Expressions</h5><p>A mutable dot expression looks like a <a href="#%28part._s~3adot-expr%29" data-pltdoc="x">dot expression</a>,
but with the dot replaced with an exclamation point (pronounced &ldquo;bang&rdquo;):</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">get-bang-expr: expr "!" NAME</span></span></p></td></tr></table></blockquote><p>A mutable dot expression first evaluates the <span class="stt">expr</span> on the left to an
object, and then looks to see if <span class="stt">NAME</span> is present in the fields of that
object.  If it is, and if the value of the field is a <a href="s_mutables.html" data-pltdoc="x"><span class="stt">Mutable</span></a>, the expression evaluates to the value currently in that
<span class="stt">Mutable</span> (after annotation checking).  If the value is not a <span class="stt">Mutable</span>,
the expression behaves as a <a href="#%28part._s~3adot-expr%29" data-pltdoc="x">dot expression</a> with the
same object and name.</p><h5>3.6.2<tt>&nbsp;</tt><a name="(part._s~3aupdate-expr)"></a>Update Expressions</h5><p>An update expression looks like a <a href="#%28part._s~3aextend-expr%29" data-pltdoc="x">object extension</a>
expression, but with the dot replaced with an exclamation point:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">update-expr: expr "!" "{" fields "}"</span></span></p></td></tr></table></blockquote><p>An update expression first evaluates the expression to the left of the <span class="stt">!</span>.
It then evaluates <span style="font-style: italic">all</span> of the expressions in <span class="stt">fields</span>, to produce a
list of field names mapping to values.  It then, in order from left to right,
checks that each name is present on the object, and is a <a href="s_mutables.html" data-pltdoc="x"><span class="stt">Mutable</span></a> value.  If any value is not present or not a <span class="stt">Mutable</span>, an
exception is signalled.  If <span style="font-style: italic">all</span> values are <span class="stt">Mutable</span>, they are all
set to the corresponding new values in the field list.  If the name-to-value
mapping appears more than once in the list, the right-most value &ldquo;wins,&rdquo; and
is the resulting value in the <span class="stt">Mutable</span> after the update.</p><p>Each update also checks the annotations for the field (if any were provided),
and signals an exception if any were violated.  <a href="s_mutables.html" data-pltdoc="x"><span class="stt">Mutables</span></a> has some additional technical details on this annotation
checking.</p><h5>3.6.3<tt>&nbsp;</tt><a name="(part._s~3alam-expr)"></a>Lambda Expressions</h5><p>The grammar for a lambda expression is:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">lambda-expr: "fun" ty-params [args] return-ann ":"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">doc-string</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">block</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where-clause</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"end"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">fun-header: ty-params NAME args return-ann</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">ty-params:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">["&lt;" list-ty-param* NAME "&gt;"]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-ty-param: NAME ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">args: (PARENSPACE|PARENNOSPACE) [list-arg-elt* binding] ")"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-arg-elt: binding ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">return-ann: ["-&gt;" ann]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">doc-string: ["doc:" STRING]</span></span></p></td></tr></table></blockquote><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The <span class="stt">ty-params</span> and <span class="stt">where-clause</span> of lambda expressions are currently not
interpreted by Pyret.  The <span class="stt">ty-params</span> will be used when Pyret has more
complete support for checking polymorphic functions.  The <span class="stt">where-clause</span> is
included for homogeneity with <a href="#%28part._s~3afun-expr%29" data-pltdoc="x">function statements</a>.</p></blockquote></blockquote></blockquote><p>A lambda expression creates a function value that can be applied with
<a href="#%28part._s~3aapp-expr%29" data-pltdoc="x">application expressions</a>.  The arguments in <span class="stt">args</span>
are bound to their arguments as immutable identifiers as in a
<a href="#%28part._s~3alet-expr%29" data-pltdoc="x">let expression</a>.  These identifiers follow the same
rules of no shadowing and no assignment.</p><p>If the arguments have <a href="#%28part._s~3aannotations%29" data-pltdoc="x">annotations</a> associated with
them, they are checked before the body of the function starts evaluating, in
order from left to right.  If an annotation fails, an exception is thrown.</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">add1 = fun(x :: Number):</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x + 1</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">add1("not-a-number")</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># Error: expected a Number and got "not-a-number"</span></span></p></td></tr></table></blockquote><p>Functions values are created with a <span class="stt">"_doc"</span> field which holds the string
value of the <span class="stt">doc-string</span> written in the function expression.  So:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">documented = fun():</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc: "Evaluates to a standards-compliant random number"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">4</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">check:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">documented._doc is "Evaluates to a standards-compliant random number"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><h5>3.6.4<tt>&nbsp;</tt><a name="(part._s~3aapp-expr)"></a>Application Expressions</h5><p>Function application expressions have the following grammar:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">app-expr: expr app-args</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">app-args: PARENNOSPACE [app-arg-elt* binop-expr] ")"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">app-arg-elt: binop-expr ","</span></span></p></td></tr></table></blockquote><p>An application expression is an expression (usually expected to evaluate to a
function), followed by a comma-separated list of arguments enclosed in
parentheses.  It first evaluates the arguments in left-to-right order, then
evaluates the function position.  If the function position is a function value,
the number of provided arguments is checked against the number of arguments
that the function expects.  If they match, the arguments names are bound to the
provided values.  If they don&rsquo;t, an exception is thrown.</p><p>Note that there is <span style="font-style: italic">no space</span> allowed before the opening parenthesis of
the application.  If you make a mistake, Pyret will complain:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">f(1) # This is the function application expression f(1)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">f (1) # This is the id-expr f, followed by the paren-expr (1)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># The second form yields a well-formedness error that there</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># are two expressions on the same line</span></span></p></td></tr></table></blockquote><h5>3.6.5<tt>&nbsp;</tt><a name="(part._s~3aleft-apply-expr)"></a>Caret Application Expressions</h5><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The grammar of <span class="stt">left-app-fun-expr</span> is restricted to avoid confusing
constructions, like:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">obj^f(1)(2)</span></span></p></td></tr></table></blockquote><p>in which it would be unclear if the function to call is <span class="stt">f</span> or <span class="stt">f(1)</span>.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">An application can also be written with a caret symbol <span class="stt">^</span>:</div></p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">left-app-expr: expr "^" left-app-fun-expr app-args</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">left-app-fun-expr: id-expr | id-expr "." NAME</span></span></p></td></tr></table></blockquote><p>This is merely syntactic sugar for putting the initial <span class="stt">expr</span> as the first
argument of an application to the <span class="stt">left-app-fun-expr</span>.  These are equivalent:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">obj^f(1, 2, 3)</span></span></p></td></tr></table></blockquote><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">f(obj, 1, 2, 3)</span></span></p></td></tr></table></blockquote><p>This allows for patterns like method-chaining on values that do not have
methods defined.  For example, one could write a function <span class="stt">add-each</span> that
adds to each element of a list, and another function <span class="stt">square</span> that
squares them, and chain them linearly:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">check:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">[1,2,3]^inc(1)^square() is [4, 9, 16]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><h5>3.6.6<tt>&nbsp;</tt><a name="(part._s~3acurried-apply-expr)"></a>Curried Application Expressions</h5><p>Suppose a function is defined with multiple arguments:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">fun f(v, w, x, y, z): ... end</span></span></p></td></tr></table></blockquote><p>Sometimes, it is particularly convenient to define a new function that
calls <span class="stt">f</span> with some arguments pre-specified:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">call-f-with-123 = fun(y, z): f(1, 2, 3, y, z) end</span></span></p></td></tr></table></blockquote><p>Pyret provides syntactic sugar to make writing such helper functions
easier:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">call-f-with-123 = f(1, 2, 3, _, _) # same as the fun expression above</span></span></p></td></tr></table></blockquote><p>Specifically, when Pyret code contains a function application some of
whose arguments are underscores, it constructs an anonymous function
with the same number of arguments as there were underscores in the
original expression, whose body is simply the original function
application, with the underscores replaced by the names of the
arguments to the anonymous function.</p><p>This syntactic sugar also works with
<a href="#%28part._s~3aleft-apply-expr%29" data-pltdoc="x">caret application expressions</a>, and
with operators.  For example, the following are two ways to sum a list
of numbers:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">[1, 2, 3, 4].foldl(fun(a, b): a + b end, 0)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">[1, 2, 3, 4].foldl(_ + _, 0)</span></span></p></td></tr></table></blockquote><p>Likewise, the following are two ways to compare two lists for
equality:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">list.map_2(fun(x, y): x == y end, first-list, second-list)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list.map_2(_ == _, first-list, second-list)</span></span></p></td></tr></table></blockquote><p>Note that there are some limitations to this syntactic sugar.  You
cannot use it with the <span class="stt">is</span> or <span class="stt">raises</span> expressions in
<a href="s_testing.html#%28part._s~3acheckers%29" data-pltdoc="x">check: blocks</a>, since both test expressions and expected
outcomes are known when writing tests.  Also, note that the sugar is
applied only to one function application at a time.  As a result, the
following code:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">_ + _ + _</span></span></p></td></tr></table></blockquote><p>desugars to</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">fun(z):</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(fun (x, y): x + y end) + z</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><p>which is probably not what was intended.  You can still write the
intended expression manually:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">fun(x, y, z): x + y + z end</span></span></p></td></tr></table></blockquote><p>Pyret just does not provide syntactic sugar to help in this case
(or other more complicated ones).</p><h5>3.6.7<tt>&nbsp;</tt><a name="(part._s~3abinop-expr)"></a>Binary Operators</h5><p>There are a number of binary operators in Pyret.  A binary operator expression
is written by putting an operator between two other expressions, as in:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">binop-expr: binop-expr BINOP binop-expr</span></span></p></td></tr></table></blockquote><p>Each binary operator is syntactic sugar for a particular method or function
call.  The following table lists the operators, their intended use, and the
corresponding call:</p><p><table cellspacing="0"><tr><td><p><span class="stt">left + right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._plus(right)</span></p></td></tr><tr><td><p><span class="stt">left - right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._minus(right)</span></p></td></tr><tr><td><p><span class="stt">left * right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._times(right)</span></p></td></tr><tr><td><p><span class="stt">left / right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._divide(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessthan(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterthan(right)</span></p></td></tr><tr><td><p><span class="stt">left and right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._and(fun(): right;)</span></p></td></tr><tr><td><p><span class="stt">left or right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._or(fun(): right;)</span></p></td></tr><tr><td><p><span class="stt">left == right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">builtins.equiv(left, right)</span></p></td></tr><tr><td><p><span class="stt">left &lt;&gt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">builtins.equiv(left, right)._not()</span></p></td></tr></table></p><p>For builtin values like lists, strings, numbers, and booleans, all of these
calls are already defined.  The special names allow a form of operator
overloading, and avoid adding an extra concept beyond function and method calls
to the core to account for these binary operations.</p><p>The boolean operators <span class="stt">and</span> and <span class="stt">or</span> are defined to wrap their argument
in a function to allow for short-circuiting.</p><h5>3.6.8<tt>&nbsp;</tt><a name="(part._s~3aobj-expr)"></a>Object Expressions</h5><p>Object expressions map field names to values:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">obj-expr: "{" fields "}" | "{" "}"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">fields: list-field* field [","]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-field: field ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">field: key ":" binop-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| key args return-ann ":" doc-string block where-clause "end"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">key: NAME | "[" binop-expr "]"</span></span></p></td></tr></table></blockquote><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The ability to define fields as computed strings using
<span class="stt">["brack" + "ets"]</span> is deprecated, and will be replaced in the future by
other reflective operations on objects and dictionaries.</p></blockquote></blockquote></blockquote><p>A comma-separated sequence of fields enclosed in <span class="stt">{}</span> creates an object; we
refer to the expression as an <span style="font-style: italic">object literal</span>.  There are two types of
fields: <span style="font-style: italic">data</span> fields and <span style="font-style: italic">method</span> fields.  A data field in an object
literal simply creates a field with that name on the resulting object, with its
value equal to the right-hand side of the field.  A method field</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">key args return-ann ":" doc-string block where-clause "end"</span></span></p></td></tr></table></blockquote><p>is syntactic sugar for:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">key ":" "method" args return-ann ":" doc-string block where-clause "end"</span></span></p></td></tr></table></blockquote><p>That is, it&rsquo;s just special syntax for a data field that contains a method
value.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The overriding of later fields is expected to be deprecated and
replaced with an error.</p></blockquote></blockquote></blockquote><p>The fields are evaluated in order.  If the same field appears more than once,
the later use overrides the earlier use, but both field expressions are still
evaluated.</p><h5>3.6.9<tt>&nbsp;</tt><a name="(part._s~3alist-expr)"></a>List Expressions</h5><p>A list expression is a sequence of comma-separated expressions enclosed in
<span class="stt">[]</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">list-elt: binop-expr ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-expr: "[" [list-elt* binop-expr] "]"</span></span></p></td></tr></table></blockquote><p>An empty list literal <span class="stt">[]</span> is syntactic sugar for <span class="stt">list.empty</span>.</p><p>A list with elements in it is transformed into a sequence of nested calls to
<span class="stt">list.link</span>, ending in <span class="stt">list.empty</span>.  For example:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">[1,2,3]</span></span></p></td></tr></table></blockquote><p>becomes</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">list.link(1, list.link(2, list.link(3, list.empty)))</span></span></p></td></tr></table></blockquote><p>See the documentation for <a href="s_lists.html" data-pltdoc="x">lists</a> for more information on
the values created by <span class="stt">list.link</span> and <span class="stt">list.empty</span>.</p><h5>3.6.10<tt>&nbsp;</tt><a name="(part._s~3adot-expr)"></a>Dot Expressions</h5><p>A dot expression is any expression, followed by a dot and name:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">dot-expr: expr "." NAME</span></span></p></td></tr></table></blockquote><p>A dot expression evaluates the <span class="stt">expr</span> to a value <span class="stt">val</span>, and then does one
of five things:</p><ul><li><p>Raises an exception, if <span class="stt">NAME</span> is not a field of <span class="stt">expr</span></p></li><li><p>Evaluates to the value stored in <span class="stt">NAME</span>, if <span class="stt">NAME</span> is present and
not a method, mutable, or placeholder value</p></li><li><p>Raises an exception, if the value stored in <span class="stt">NAME</span> is a <span class="stt">mutable</span> field.</p></li><li><p>Evaluates to the value stored in the placeholder stored in <span class="stt">NAME</span>,
if the value is a placeholder value.</p></li><li><p>If the <span class="stt">NAME</span> field is a method value, evaluates to a function that is
the <span style="font-style: italic">method binding</span> of the method value to <span class="stt">val</span>.  For a method</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">m = method(self, x): body end</span></span></p></td></tr></table></blockquote><p>The <span style="font-style: italic">method binding</span> of <span class="stt">m</span> to a value <span class="stt">v</span> is equivalent to:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">(fun(self): fun(x): body end end)(v)</span></span></p></td></tr></table></blockquote><p>What this detail means is that you can look up a method and it
automatically closes over the value on the left-hand side of the dot.  This
bound method can be freely used as a function.</p><p>For example:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">o = { m(self, x): self.y + x end, y: 22 }</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">check:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">the-m-method-closed-over-o = o.m</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">m(5) is 27</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote></li></ul><h5>3.6.11<tt>&nbsp;</tt><a name="(part._s~3acolon-expr)"></a>Colon Expressions</h5><p>The colon expression is like the dot expression, but does not perform method
binding.  It is written as a dot expression, but with <span class="stt">:</span> rather than <span class="stt">.</span>.</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">colon-expr: expr ":" NAME</span></span></p></td></tr></table></blockquote><p>A colon expression evaluates <span class="stt">expr</span> and then evaluates to the <span class="stt">NAME</span>
value from the resulting object.  It signals an error if <span class="stt">NAME</span> is absent.
The key distinction between <span class="stt">:</span> and <span class="stt">.</span> is that a colon expression does
not pre-apply methods, signal an exception on <a href="s_mutables.html" data-pltdoc="x"><span class="stt">Mutables</span></a>, or automatically unwrap <a href="s_placeholders.html" data-pltdoc="x"><span class="stt">Placeholder</span></a> values.  This has value in more sophisticated patterns, like
those used by Pyret&rsquo;s generic equality and <span class="stt">tostring</span> algorithms.</p><h5>3.6.12<tt>&nbsp;</tt><a name="(part._s~3aextend-expr)"></a>Extend Expressions</h5><p>The extend expression consists of an base expression and a list of fields to
extend it with:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">extend-expr: expr "." "{" fields "}"</span></span></p></td></tr></table></blockquote><p>The extend expression first evaluates <span class="stt">expr</span> to a value <span class="stt">val</span>, and then
creates a new object with all the fields of <span class="stt">val</span> and <span class="stt">fields</span>.  If a
field is present in both, the new field is used.</p><p>Examples:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">check:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o = {x : "original-x", y: "original-y"}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2 = o.{x : "new-x", z : "new-z"}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2.x is "new-x"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2.y is "original-y"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2.z is "new-z"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><h5>3.6.13<tt>&nbsp;</tt><a name="(part._s~3aif-expr)"></a>If Expressions</h5><h5>3.6.14<tt>&nbsp;</tt><a name="(part._s~3acases-expr)"></a>Cases Expressions</h5><p>A cases expression consists of a datatype (in parentheses), an expression to
inspect (before the colon), and a number of branches.  It is intended to be
used in a structure parallel to a data definition.</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">cases-expr: "cases" (PARENSPACE|PARENNOSPACE) expr-check ")" expr-target ":"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">cases-branch*</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">["|" "else" "=&gt;" block]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"end"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">cases-branch: "|" NAME [args] "=&gt;" block</span></span></p></td></tr></table></blockquote><p>A <span class="stt">cases</span> expression first evaluates <span class="stt">expr-check</span> to get a checker for
the type of the value to branch on.  Typically, this should be the name of a
datatype like <span class="stt">list.List</span>.  The expression then evaluates <span class="stt">expr-target</span>,
and checks if it matches the given annotation.  If it does not, an exception is
raise, otherwise it proceeds to match it against the given cases.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p> Under the hood, <span class="stt">cases</span> is calling the <span class="stt">_match</span> function of
the target value, which is defined for each variant and performs the
appropriate dispatch.</p></blockquote></blockquote></blockquote><p>Cases should use the names of the variants of the given data type as the
<span class="stt">NAME</span>s of each branch.  The branches will be tried, in order, checking if
the given value is an instance of that variant.  If it matches, the fields of
the variant are bound, in order, to the provided <span class="stt">args</span>, and the right-hand
side of the <span class="stt">=&gt;</span> is evaluated in that extended environment.  An exception
results if the wrong number of arguments are given.</p><p>An optional <span class="stt">else</span> clause can be provided, which is evaluated if no cases
match.  If no <span class="stt">else</span> clause is provided, a default is used that raises an
exception.</p><p>For example, a cases expression on lists looks like:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">check:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result = cases(list.List) [1,2,3]:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| empty =&gt; "empty"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| link(f, r) =&gt; "link"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result is "link"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result2 = cases(list.List) [1,2,3]:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| empty =&gt; "empty"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| else =&gt; "else"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result2 is else</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result3 = cases(list.List) empty:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| empty =&gt; "empty"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| else =&gt; "else"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result3 is "empty"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><h5>3.6.15<tt>&nbsp;</tt><a name="(part._s~3afor-expr)"></a>For Expressions</h5><p>For expressions consist of the <span class="stt">for</span> keyword, followed by a list of
<span class="stt">binding from expr</span> clauses in parentheses, followed by a block:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">for-expr: "for" expr PARENNOSPACE [for-bind-elt* for-bind] ")" return-ann ":"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">"end"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">for-bind-elt: for-bind ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">for-bind: binding "from" binop-expr</span></span></p></td></tr></table></blockquote><p>The for expression is just syntactic sugar for a
<a href="#%28part._s~3alam-expr%29" data-pltdoc="x"><span class="stt">lam-expr</span></a> and a <a href="#%28part._s~3aapp-expr%29" data-pltdoc="x"><span class="stt">app-expr</span></a>.  An expression</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">for fun-expr(arg1 :: ann1 from expr1, ...) -&gt; ann-return:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr></table></blockquote><p>is equivalent to:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">fun-expr(fun(arg1 :: ann1, ...) -&gt; ann-return: block end, expr1, ...)</span></span></p></td></tr></table></blockquote><p>Using a <span class="stt">for-expr</span> can be a more natural way to call, for example, list
iteration functions because it puts the identifier of the function and the
value it draws from closer to one another.  Use of <span class="stt">for-expr</span> is a matter of
style; here is an example that compares <span class="stt">fold</span> with and without <span class="stt">for</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">for fold(sum from 0, number from [1,2,3,4]):</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">sum + number</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">fold(fun(sum, number): sum + number end, [1,2,3,4])</span></span></p></td></tr></table></blockquote><h5>3.6.16<tt>&nbsp;</tt><a name="(part._s~3atry-expr)"></a>Try Expressions</h5><h4>3.7<tt>&nbsp;</tt><a name="(part._s~3aannotations)"></a>Annotations</h4><p>Annotations in Pyret express intended types values will have at runtime.
They appear next to identifiers anywhere a <span class="stt">binding</span> is specified in the
grammar, and if an annotation is present adjacent to an identifier, the program
is compiled to raise an error if the value bound to that identifier would
behave in a way that violates the annotation.  The annotation provides a
<span style="font-style: italic">guarantee</span> that either the value will behave in a particular way, or the
program will raise an exception.</p><h5>3.7.1<tt>&nbsp;</tt><a name="(part._s~3aname-ann)"></a>Name Annotations</h5><p>Some annotations are simply names.  For example, a
<a href="#%28part._s~3adata-expr%29" data-pltdoc="x"><span class="stt">data declaration</span></a> binds the name of the
declaration as a value suitable for use as a name annotation.  There are
built-in name annotations, too:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">Any</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">Number</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">String</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">Bool</span></span></p></td></tr></table></blockquote><p>Each of these names represents a particular type of runtime value, and using
them in annotation position will check each time the identifier is bound that
the value is of the right type.</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">x :: Number = "not-a-number"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># Error: expected Number and got "not-a-number"</span></span></p></td></tr></table></blockquote><p><span class="stt">Any</span> is an annotation that allows any value to be used.  It semantically
equivalent to not putting an annotation on an identifier, but it allows a
program to clearly signal that no restrictions are intended for the identifier
it annotates.</p><h5>3.7.2<tt>&nbsp;</tt><a name="(part._s~3aarrow-ann)"></a>Arrow Annotations</h5><p>An arrow annotation is used to describe the behavior of functions.  It consists
of a list of comma-separated argument types followed by an ASCII arrow and
return type:</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt">arrow-ann: (PARENSPACE|PARENNOSPACE) arrow-ann-elt* ann "-&gt;" ann ")"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">arrow-ann-elt: ann ","</span></span></p></td></tr></table></blockquote><p>When an arrow annotation appears in a binding, that binding position
<span style="font-style: italic">wraps</span> values that are bound to it in a new function.  This new function,
when applied, checks that the arguments match the provided list of argument
annotations, and if any fail, raises an exception.  When (or if) the function
finishes evaluating to a value, it checks that the resulting value matches the
<span style="font-style: italic">return annotation</span>, which appears after the arrow, again signalling an
exception if it does not.</p><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt"># This line does not cause an error yet</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">f :: (Number -&gt; String) = fun(x): x + 1 end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># This raises an exception "Expected Number, got 'not-a-number'"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">f("not-a-number")</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># This raises an exception "Expected String, got 4"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">f(3)</span></span></p></td></tr></table></blockquote><h4>3.8<tt>&nbsp;</tt><a name="(part._.Complete_.Grammar)"></a>Complete Grammar</h4><blockquote class="SCodeFlow"><table cellspacing="0"><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">program: prelude block</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">end: "end" | ";"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">prelude: [provide-stmt] import-stmt*</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">import-stmt: "import" (import-name | import-string) "as" NAME</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">import-name: NAME</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">import-string: STRING</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">provide-stmt: "provide" stmt end | "provide" "*"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">block: stmt*</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">stmt: let-expr | fun-expr | data-expr | datatype-expr | when-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| var-expr | assign-expr | check-test | check-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| graph-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">let-expr: binding "=" binop-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">binding: NAME ["::" ann]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">fun-expr: "fun" fun-header ":" doc-string block where-clause end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">fun-header: ty-params NAME args return-ann</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">ty-params:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">["&lt;" list-ty-param* NAME "&gt;"]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-ty-param: NAME ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">args: (PARENSPACE|PARENNOSPACE) [list-arg-elt* binding] ")"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-arg-elt: binding ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">return-ann: ["-&gt;" ann]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">doc-string: ["doc:" STRING]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">where-clause: ["where:" block]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">check-expr: "check:" block end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">check-test: binop-expr check-op binop-expr | binop-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">data-expr: "data" NAME ty-params data-mixins ":" [first-data-variant] data-variant* data-sharing where-clause end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">data-mixins: ["deriving" mixins]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">first-data-variant: NAME variant-members data-with | NAME data-with</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">data-variant: "|" NAME variant-members data-with | "|" NAME data-with</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">variant-members: (PARENSPACE|PARENNOSPACE) [list-variant-member* variant-member] ")"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-variant-member: variant-member ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">variant-member: ["mutable"|"cyclic"] binding</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">data-with: ["with:" fields]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">data-sharing: ["sharing:" fields]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">mixins: list-mixin* binop-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-mixin: binop-expr ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">datatype-expr: "datatype" NAME ty-params ":" [first-datatype-variant] datatype-variant* where-clause end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">first-datatype-variant: NAME variant-members constructor-clause | NAME constructor-clause</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">datatype-variant: "|" NAME variant-members constructor-clause | "|" NAME constructor-clause</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">constructor-clause: "with constructor" (PARENSPACE|PARENNOSPACE) NAME ")" ":" block end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">var-expr: "var" binding "=" binop-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">assign-expr: NAME ":=" binop-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">graph-expr: "graph:" let-expr* end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">when-expr: "when" binop-expr ":" block end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">binop-expr: not-expr | binop-expr binop binop-expr | expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">not-expr: "not" expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">binop: "+"<span class="hspace">&nbsp;&nbsp;</span>| "-"<span class="hspace">&nbsp;&nbsp;</span>| "*"<span class="hspace">&nbsp;&nbsp;</span>| "/"<span class="hspace">&nbsp;&nbsp;</span>| "&lt;="<span class="hspace">&nbsp;&nbsp;</span>| "&gt;="<span class="hspace">&nbsp;&nbsp;</span><span class="stt">| "=="</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>| "&lt;&gt;"<span class="hspace">&nbsp;&nbsp;</span>| "&lt;"<span class="hspace">&nbsp;&nbsp;</span><span class="stt">| "&gt;" | "and" | "or"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">check-op: "is" | "raises" | "satisfies"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">expr: paren-expr | id-expr | prim-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| lambda-expr | method-expr | app-expr | left-app-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| obj-expr | list-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| dot-expr | bracket-expr | colon-expr | colon-bracket-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| get-bang-expr | update-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| extend-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| if-expr | cases-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| for-expr | try-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| user-block-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># paren-exprs must be preceded by a space, so as not be be confused with</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># function application</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">paren-expr: PARENSPACE binop-expr ")"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">id-expr: NAME</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">prim-expr: num-expr | bool-expr | string-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">num-expr: NUMBER | "-" NUMBER</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">bool-expr: "true" | "false"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">string-expr: STRING</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">lambda-expr: "fun" ty-params [args] return-ann ":" doc-string block where-clause end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">method-expr: "method" args return-ann ":" doc-string block where-clause end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">app-expr: expr app-args</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># application must have the function expression immediately adjacent to</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"># the argument list, so as not to be confused with parenthesized exprs</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">app-args: PARENNOSPACE [app-arg-elt* binop-expr] ")"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">app-arg-elt: binop-expr ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">left-app-expr: expr "^" left-app-fun-expr app-args</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">left-app-fun-expr: id-expr | id-expr "." NAME</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">obj-expr: "{" obj-fields "}" | "{" "}"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">obj-fields: list-obj-field* obj-field [","]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-obj-field: obj-field ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">obj-field: key ":" binop-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| "mutable" key ["::" ann] ":" binop-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| key args return-ann ":" doc-string block where-clause end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">fields: list-field* field [","]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-field: field ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">field: key ":" binop-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| key args return-ann ":" doc-string block where-clause end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">key: NAME | "[" binop-expr "]"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-elt: binop-expr ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-expr: "[" [list-elt* binop-expr] "]"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">dot-expr: expr "." NAME</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">bracket-expr: expr "." "[" binop-expr "]"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">get-bang-expr: expr "!" NAME</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">colon-expr: expr ":" NAME</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">colon-bracket-expr: expr ":" "[" binop-expr "]"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">extend-expr: expr "." "{" fields "}"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">update-expr: expr "!" "{" fields "}"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">if-expr: "if" binop-expr ":" block else-if* ["else:" block] end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">else-if: "else if" binop-expr ":" block</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">cases-expr: "cases" (PARENSPACE|PARENNOSPACE) ann ")" expr ":" cases-branch* ["|" "else" "=&gt;" block] end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">cases-branch: "|" NAME [args] "=&gt;" block</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">for-bind: binding "from" binop-expr</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">for-bind-elt: for-bind ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">for-expr: "for" expr PARENNOSPACE [for-bind-elt* for-bind] ")" return-ann ":" block end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">try-expr: "try:" block "except" (PARENSPACE|PARENNOSPACE) binding ")" ":" block end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">user-block-expr: "block:" block end</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">ann: name-ann | record-ann | arrow-ann | app-ann | pred-ann | dot-ann</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">name-ann: NAME</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">record-ann: "{" [list-ann-field* ann-field] "}"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| "{" "}"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">list-ann-field: ann-field ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">ann-field: NAME ":" ann | NAME "::" ann</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">arrow-ann: (PARENSPACE|PARENNOSPACE) [arrow-ann-elt* ann] "-&gt;" ann ")"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">arrow-ann-elt: ann ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">app-ann: (name-ann|dot-ann) "&lt;" app-ann-elt* ann "&gt;"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt">app-ann-elt: ann ","</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">pred-ann: ann (PARENSPACE|PARENNOSPACE) binop-expr ")"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="stt"></span></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"><span class="stt">dot-ann : NAME "." NAME</span></span></p></td></tr></table></blockquote><div class="navsetbottom"><span class="navleft">&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="s_running.html" title="backward to &quot;2 Editing and Running Pyret&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="http://www.pyret.org/docs/index.html" title="up to &quot;Pyret Language Reference&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_testing.html" title="forward to &quot;4 Testing&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body>
<!-- Mirrored from www.pyret.org/docs/s_forms.html by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 24 Apr 2014 07:13:04 GMT -->
</html>